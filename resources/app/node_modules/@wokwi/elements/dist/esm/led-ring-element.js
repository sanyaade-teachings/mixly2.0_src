var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement, svg } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { mmToPix } from './utils/units';
const pinHeight = 3;
const pcbWidth = 6;
let LEDRingElement = class LEDRingElement extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * Number of pixels to in the LED ring
         */
        this.pixels = 16;
        /**
         * Space between pixels (in mm)
         */
        this.pixelSpacing = 0;
        /**
         * Background (PCB) color
         */
        this.background = '#363';
        /**
         * Animate the LEDs in the matrix. Used primarily for testing in Storybook.
         * The animation sequence is not guaranteed and may change in future releases of
         * this element.
         */
        this.animation = false;
        this.pixelElements = null;
        this.animationFrame = null;
        this.animateStep = () => {
            const time = new Date().getTime();
            const { pixels } = this;
            const pixelValue = (n) => (n % 2000 > 1000 ? 1 - (n % 1000) / 1000 : (n % 1000) / 1000);
            for (let pixel = 0; pixel < pixels; pixel++) {
                this.setPixel(pixel, {
                    r: pixelValue(pixel * 100 + time),
                    g: pixelValue(pixel * 100 + time + 200),
                    b: pixelValue(pixel * 100 + time + 400),
                });
            }
            this.animationFrame = requestAnimationFrame(this.animateStep);
        };
    }
    get radius() {
        return ((this.pixelSpacing + 5) * this.pixels) / 2 / Math.PI + pcbWidth;
    }
    get pinInfo() {
        const { radius } = this;
        const pinSpacing = 2.54;
        const y = (radius * 2 + pinHeight) * mmToPix;
        const cx = radius * mmToPix;
        const p = pinSpacing * mmToPix;
        return [
            {
                name: 'GND',
                x: cx - 1.5 * p,
                y,
                signals: [{ type: 'power', signal: 'GND' }],
            },
            { name: 'VCC', x: cx - 0.5 * p, y, signals: [{ type: 'power', signal: 'VCC' }] },
            { name: 'DIN', x: cx + 0.5 * p, y, signals: [] },
            { name: 'DOUT', x: cx + 1.5 * p, y, signals: [] },
        ];
    }
    getPixelElements() {
        if (!this.shadowRoot) {
            return null;
        }
        if (!this.pixelElements) {
            this.pixelElements = Array.from(this.shadowRoot.querySelectorAll('rect.pixel'));
        }
        return this.pixelElements;
    }
    setPixel(pixel, { r, g, b }) {
        const pixelElements = this.getPixelElements();
        if (!pixelElements) {
            return;
        }
        if (pixel < 0 || pixel >= pixelElements.length) {
            return;
        }
        pixelElements[pixel].style.fill = `rgb(${r * 255},${g * 255},${b * 255})`;
    }
    /**
     * Resets all the pixels to off state (r=0, g=0, b=0).
     */
    reset() {
        const pixelElements = this.getPixelElements();
        for (const element of pixelElements !== null && pixelElements !== void 0 ? pixelElements : []) {
            element.style.fill = '';
        }
    }
    updated() {
        if (this.animation && !this.animationFrame) {
            this.animationFrame = requestAnimationFrame(this.animateStep);
        }
        else if (!this.animation && this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
        }
    }
    render() {
        const { pixels, radius, background } = this;
        const pixelElements = [];
        const width = radius * 2;
        const height = radius * 2 + pinHeight;
        for (let i = 0; i < pixels; i++) {
            const angle = (i / pixels) * 360;
            pixelElements.push(svg `<rect
          class="pixel"
          x="${radius - 2.5}"
          y="${pcbWidth / 2 - 2.5}"
          width="5"
          height="5"
          fill="white"
          stroke="black"
          stroke-width="0.25"
          transform="rotate(${angle} ${radius} ${radius})"/>`);
        }
        this.pixelElements = null; // Invalidate element cache
        return html `
      <svg
        width="${width}mm"
        height="${height}mm"
        version="1.1"
        viewBox="0 0 ${width} ${height}"
        xmlns="http://www.w3.org/2000/svg"
      >
        <defs>
          <pattern id="pin-pattern" height="2" width="2.54" patternUnits="userSpaceOnUse">
            <rect x="1.02" y="0" height="2" width="0.5" fill="#aaa" />
          </pattern>
        </defs>
        <rect
          fill="url(#pin-pattern)"
          height="${pinHeight + 1}"
          width=${4 * 2.54}
          transform="translate(${radius - (4 * 2.54) / 2}, ${radius * 2 - 1})"
        />
        <circle
          cx="${radius}"
          cy="${radius}"
          r="${radius - pcbWidth / 2}"
          fill="transparent"
          stroke-width="${pcbWidth}"
          stroke="${background}"
        />
        ${pixelElements}
      </svg>
    `;
    }
};
__decorate([
    property()
], LEDRingElement.prototype, "pixels", void 0);
__decorate([
    property({ type: Number })
], LEDRingElement.prototype, "pixelSpacing", void 0);
__decorate([
    property()
], LEDRingElement.prototype, "background", void 0);
__decorate([
    property()
], LEDRingElement.prototype, "animation", void 0);
LEDRingElement = __decorate([
    customElement('wokwi-led-ring')
], LEDRingElement);
export { LEDRingElement };
