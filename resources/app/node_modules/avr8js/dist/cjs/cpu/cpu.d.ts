/**
 * AVR 8 CPU data structures
 * Part of AVR8js
 *
 * Copyright (C) 2019, Uri Shaked
 */
import { AVRIOPort } from '../peripherals/gpio';
import { u32, u16, u8, i16 } from '../types';
export declare type CPUMemoryHook = (value: u8, oldValue: u8, addr: u16, mask: u8) => boolean | void;
export interface CPUMemoryHooks {
    [key: number]: CPUMemoryHook;
}
export declare type CPUMemoryReadHook = (addr: u16) => u8;
export interface CPUMemoryReadHooks {
    [key: number]: CPUMemoryReadHook;
}
export interface AVRInterruptConfig {
    address: u8;
    enableRegister: u16;
    enableMask: u8;
    flagRegister: u16;
    flagMask: u8;
    constant?: boolean;
    inverseFlag?: boolean;
}
export declare type AVRClockEventCallback = () => void;
export declare class CPU {
    progMem: Uint16Array;
    private sramBytes;
    readonly data: Uint8Array;
    readonly data16: Uint16Array;
    readonly dataView: DataView;
    readonly progBytes: Uint8Array;
    readonly readHooks: CPUMemoryReadHooks;
    readonly writeHooks: CPUMemoryHooks;
    private readonly pendingInterrupts;
    private nextClockEvent;
    private readonly clockEventPool;
    /**
     * Whether the program counter (PC) can address 22 bits (the default is 16)
     */
    readonly pc22Bits: boolean;
    readonly gpioPorts: Set<AVRIOPort>;
    readonly gpioByPort: AVRIOPort[];
    /**
     * This function is called by the WDR instruction. The Watchdog peripheral attaches
     * to it to listen for WDR (watchdog reset).
     */
    onWatchdogReset: () => void;
    /**
     * Program counter
     */
    pc: u32;
    /**
     * Clock cycle counter
     */
    cycles: number;
    nextInterrupt: i16;
    maxInterrupt: i16;
    constructor(progMem: Uint16Array, sramBytes?: number);
    reset(): void;
    readData(addr: number): number;
    writeData(addr: number, value: number, mask?: number): void;
    get SP(): number;
    set SP(value: number);
    get SREG(): number;
    get interruptsEnabled(): boolean;
    setInterruptFlag(interrupt: AVRInterruptConfig): void;
    updateInterruptEnable(interrupt: AVRInterruptConfig, registerValue: u8): void;
    queueInterrupt(interrupt: AVRInterruptConfig): void;
    clearInterrupt({ address, flagRegister, flagMask }: AVRInterruptConfig, clearFlag?: boolean): void;
    clearInterruptByFlag(interrupt: AVRInterruptConfig, registerValue: number): void;
    addClockEvent(callback: AVRClockEventCallback, cycles: number): AVRClockEventCallback;
    updateClockEvent(callback: AVRClockEventCallback, cycles: number): boolean;
    clearClockEvent(callback: AVRClockEventCallback): boolean;
    tick(): void;
}
