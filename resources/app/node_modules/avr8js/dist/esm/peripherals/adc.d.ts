/**
 * AVR-8 ADC
 * Part of AVR8js
 * Reference: http://ww1.microchip.com/downloads/en/DeviceDoc/ATmega48A-PA-88A-PA-168A-PA-328-P-DS-DS40002061A.pdf
 *
 * Copyright (C) 2019, 2020, 2021 Uri Shaked
 */
import { CPU } from '../cpu/cpu';
import { u8 } from '../types';
export declare enum ADCReference {
    AVCC = 0,
    AREF = 1,
    Internal1V1 = 2,
    Internal2V56 = 3,
    Reserved = 4
}
export declare enum ADCMuxInputType {
    SingleEnded = 0,
    Differential = 1,
    Constant = 2,
    Temperature = 3
}
export declare type ADCMuxInput = {
    type: ADCMuxInputType.Temperature;
} | {
    type: ADCMuxInputType.Constant;
    voltage: number;
} | {
    type: ADCMuxInputType.SingleEnded;
    channel: number;
} | {
    type: ADCMuxInputType.Differential;
    positiveChannel: number;
    negativeChannel: number;
    gain: number;
};
export declare type ADCMuxConfiguration = {
    [key: number]: ADCMuxInput;
};
export interface ADCConfig {
    ADMUX: u8;
    ADCSRA: u8;
    ADCSRB: u8;
    ADCL: u8;
    ADCH: u8;
    DIDR0: u8;
    adcInterrupt: u8;
    numChannels: u8;
    muxInputMask: u8;
    muxChannels: ADCMuxConfiguration;
    adcReferences: ADCReference[];
}
export declare const atmega328Channels: ADCMuxConfiguration;
export declare const adcConfig: ADCConfig;
export declare class AVRADC {
    private cpu;
    private config;
    /**
     * ADC Channel values, in voltage (0..5). The number of channels depends on the chip.
     *
     * Changing the values here will change the ADC reading, unless you override onADCRead() with a custom implementation.
     */
    readonly channelValues: any[];
    /** AVCC Reference voltage */
    avcc: number;
    /** AREF Reference voltage */
    aref: number;
    /**
     * Invoked whenever the code performs an ADC read.
     *
     * The default implementation reads the result from the `channelValues` array, and then calls
     * `completeADCRead()` after `sampleCycles` CPU cycles.
     *
     * If you override the default implementation, make sure to call `completeADCRead()` after
     * `sampleCycles` cycles (or else the ADC read will never complete).
     */
    onADCRead: (input: ADCMuxInput) => void;
    private converting;
    private conversionCycles;
    private ADC;
    constructor(cpu: CPU, config: ADCConfig);
    completeADCRead(value: number): void;
    get prescaler(): 2 | 4 | 8 | 32 | 16 | 128 | 64;
    get referenceVoltageType(): ADCReference;
    get referenceVoltage(): number;
    get sampleCycles(): number;
}
