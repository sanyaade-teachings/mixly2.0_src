import { CPU } from '../cpu/cpu';
import { u8 } from '../types';
export interface SPIConfig {
    spiInterrupt: u8;
    SPCR: u8;
    SPSR: u8;
    SPDR: u8;
}
export declare const spiConfig: SPIConfig;
export declare type SPITransferCallback = (value: u8) => number;
export declare type SPIByteTransferCallback = (value: u8) => void;
export declare class AVRSPI {
    private cpu;
    private config;
    private freqHz;
    /** @deprecated Use onByte() instead */
    onTransfer: SPITransferCallback;
    /**
     * SPI byte transfer callback. Invoked whenever the user code starts an SPI transaction.
     * You can override this with your own SPI handler logic.
     *
     * The callback receives a argument: the byte sent over the SPI MOSI line.
     * It should call `completeTransfer()` within `transferCycles` CPU cycles.
     */
    onByte: SPIByteTransferCallback;
    private transmissionActive;
    private SPI;
    constructor(cpu: CPU, config: SPIConfig, freqHz: number);
    reset(): void;
    /**
     * Completes an SPI transaction. Call this method only from the `onByte` callback.
     *
     * @param receivedByte Byte read from the SPI MISO line.
     */
    completeTransfer(receivedByte: number): void;
    get isMaster(): boolean;
    get dataOrder(): "lsbFirst" | "msbFirst";
    get spiMode(): 0 | 2 | 1 | 3;
    /**
     * The clock divider is only relevant for Master mode
     */
    get clockDivider(): number;
    /** Number of cycles to complete a single byte SPI transaction */
    get transferCycles(): number;
    /**
     * The SPI freqeuncy is only relevant to Master mode.
     * In slave mode, the frequency can be as high as F(osc) / 4.
     */
    get spiFrequency(): number;
}
